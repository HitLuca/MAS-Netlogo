__includes["support_files/messages.nls" "support_files/distances_calculations.nls" "support_files/passengers_calculations.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  distance_matrix
  passengers_matrix
  mother_station
  going_in_service
  
  ;independent
  station_beliefs
  bus_count
  ;companions
  
  leader
  new_buses
  
  vote_distance_threshold
  faction
  
  last_order_tick
  pending_orders
  
  asked_support
  help_candidates
  help_distance_threshold
  
  starting_buses
  
  ;attractivness protocols
  attractivness
  
]

globals [graph]

;initialization of the buses
to init-buses
  if graph = 0 [
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ]
  
  ; Initialize your agents here.
  
  set distance_matrix load-distances
  set passengers_matrix load-passengers
  
  set starting_buses 5
  
  set station_beliefs []
  let i 0
  while [i < 24] [
    set station_beliefs lput [] station_beliefs
    set i (i + 1)
  ]
  
  ifelse bus_id < 49[
    set mother_station (bus_id - 25) ; mod 24; to the one of the bus that asked for support (check inbox)
    set bus_count starting_buses + 1
    set help_candidates []
  ]
  [
    set mother_station -1
  ]
  
  set leader 24
  
  set last_order_tick 0
  set going_in_service True
  
  if leader = bus_id[
    set new_buses []
    set pending_orders []
  ]
  
  set vote_distance_threshold 10
  
  ifelse random 3 = 0[ ;buses can be cheap or fast, randomly assigned with different probabilities (1/3 and 2/3)
    set faction "cheap"
    ;less prone to buy or vote in favour of new buses, they care more about economic efficiency
  ]
  [
    set faction "fast"
    ;more interested in bringing people around faster, they are more likely to order and vote for new buses
  ]
  
  set asked_support []
  set help_distance_threshold 10
  
  
  set attractivness []
  set i 0
  while [i < 24] [
    ifelse i = mother_station[
      set attractivness lput 0 attractivness
    ]
    [
      set attractivness lput 1 attractivness
    ]
    set i (i + 1)
  ]

end

;--------------------------------------------------------;
;--------------------MAIN ROUTINE------------------------;
;--------------------------------------------------------;
to execute-actions
  if bus_id = 24 and ticks = 2 [
    let i 0
    ;let node_stations [0 3 13 16 22 23 ...] ; this are the main nodes of the graph, the ones that have a fixed bus
    while [i < starting_buses ] [ ; [i < length node_stations] [
      add-bus 3
      set i i + 1
    ]
    set mother_station 3
  ]
  
  handle-messages
  
  update-beliefs
  
  if mother_station != -1[
    if at-stop [
      drop-passengers ;everytime you reach a stop you drop all passengers
      ifelse going_in_service[ ; this part decides which will be the next_stop
        go-to-mother_station
      ]
      [
        ;buses decide their mother_station based on where they are more needed (
;        if current_stop != mother_station[
;          ;TODO this protocolo has to be improved and also consider other buses destinations and the prior
;          if (length get-passengers-at-stop mother_station) < (length get-passengers-at-stop current_stop)[
;            set mother_station current_stop ; the mother station changes to the current one if this has more passengers than the previous
;          ]
;        ]
;        
;        
;        ifelse current_stop = mother_station [
          set next_stop get-optimal-station
;        ]
;        [
;          set next_stop mother_station
;        ]
      ]
      if next_stop = -1[ ;if no local choice gives gain, search further away
        if consider-migration[
          go-to-mother_station
        ]
      ]
      ;otherwise pickup the passengers that gain from the trip
      pickup-passengers next_stop
      update-others-on-choice next_stop
    ]
    
    if next_stop != -1[ ;if no one is waiting in the motherstation the bus doesn't move.
      travel-to next_stop
    ]
  ]
end

;makes the bus move from origin to destination following the shortest path
to travel-to-destination [origin destination]
  if origin != destination [
    ifelse is-connected origin destination [
      set next_stop destination
    ]
    [
      set next_stop station-closer-to-destination origin destination
    ]
  ]
end

;checks if a bus is stopped at a station or if it's moving
to-report at-stop 
  report current_stop != -1
end

;sends a new bus to its mother station
to go-to-mother_station
  ifelse current_stop = mother_station [
    set going_in_service False
    set next_stop get-optimal-station
  ]
  [
    if at-stop [
      travel-to-destination current_stop mother_station
    ]
  ]
end

;returns the capacity of the given bus
to-report get-capacity
  if bus_type = 1[report 12]
  if bus_type = 2[report 60]
  if bus_type = 3[report 150]
end

;checks if the bus is full
to-report full 
  report (length bus_passengers = get-capacity)
end
 
;drops all the passengers
to drop-passengers
  foreach bus_passengers [
    drop-off-passenger item 0 ?
  ]
end

;pick up the passengers that will get a gain from going to that bus stop
to pickup-passengers [station]
  if station != -1[
    let left_down 0
    foreach get-passengers-at-stop current_stop [
      if distance-shortened station ? [ ;if the passenger gains something from the planned trip
        ifelse not full [ 
          pick-up-passenger item 0 ? ;if the bus has spare places it will load the passenger
        ]
        [
          set left_down (left_down + 1) ;the bus counts how many passengers couldn't load
        ]
      ]
    ]
    
    if (bus-needed? left_down current_stop) and (length asked_support = 0) [
      call-vote left_down current_stop
    ]
  ]
  
end

;checks if a new bus needs to be bought or not
to-report bus-needed? [left_down station]
  let pas_wait (length get-passengers-at-stop station) ;how many people are right now in the station
  let bus_coming length item station station_beliefs ; for now there is only one fixed bus for each stop
  let passengers_expected get-passengers-next-quarter station
  
  let threshold 0
  
  ifelse faction = "fast"[
    set threshold 250
  ]
  [
    set threshold 500
  ]
  
  let need (left_down + pas_wait + passengers_expected - bus_coming * 100)
  
  report (need > threshold) 
end

to update-beliefs
  let new_b []
  foreach station_beliefs [
    let nsb ?
    ;erase from the list of beliefs the buses that already reached their destination
    let arrived []
    foreach ?[
      if item 1 ? < ticks [ set arrived lput ? arrived ]
    ]
    foreach arrived [ set nsb remove ? nsb ]
    ;start rebuilding the beliefs list with the updated knowledge
    set new_b lput nsb new_b
  ]
  set station_beliefs new_b ;beliefs updated
end






to recalculate-attractivness
  let i 0
  set attractivness []
  while [i < 24] [
    set attractivness lput (measure-attractivness i) attractivness
    set i (i + 1)
  ]
end

to-report measure-attractivness [ station ]
  let value 0
  let station0 next_stop
  if station != station0[ ;the station soon to be reached has no attractivness, since it is a mandatory stop
    let waiting_passengers length get-passengers-at-stop station
    let bus_count_for_stop length item station station_beliefs
    let station_distance get-distance station0 station
    let prior get-passengers-next-quarter station
    
    set value (0.5 * waiting_passengers + 0.5 * prior) - 50 * bus_count_for_stop
    set value (value / station_distance)
  ]
  report value
end

to-report best-next-stop
  report position (max attractivness) attractivness
end















