buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  personal_route      ;a list of bus stops describing the line of the bus
  current_route_index ;index of the last visited stop
  returning           ;False if going in the direction of the last stop, True otherwise
  delay               ;time to delay the departure of the bus from the first stop 
  delayed             ;True - enable the delay, False - disable it
]
 
globals [graph]

to init-buses
  ; Initialize your agents here.
  
    if personal_route = 0 [
      
      ;uniformly distribute the buses to the lines
      let line_number bus_id mod 5
      
      if line_number = 0 [
        set personal_route [3 16 11 1 19 23]
      ]
      if line_number = 1 [
        set personal_route [3 4 5 17 7 1 23]
      ]
      if line_number = 2 [
        set personal_route [3 4 10 13 23]
      ]
      if line_number = 3 [
        set personal_route [3 20 21 22 12 15 18 15 0 14 23]
      ]
      if line_number = 4 [
        set personal_route [3 9 8 6 8 2 8 9 3]
      ]
      set returning False
      
      ;set the delay according to the line of the bus
      set delay 10 * (floor (bus_id / 5) - 5)
      set current_route_index 0
      set delayed True
    ]      
  

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end
  
;finds if the bus is at a stop
to-report at-stop 
  ifelse current_stop != -1 and previous_stop != -1 [
    report True
  ][report False]
end

;update the current stop index of the bus
to update-current-index
  ifelse returning [
    set current_route_index current_route_index - 1
  ][set current_route_index current_route_index + 1]
end

;checks if the bus is not full
to-report not-full 
  report (bus_type = 1 and length bus_passengers != 12) or (bus_type = 2 and length bus_passengers != 60) or (bus_type = 3 and length bus_passengers != 150)
end

;checks if the the first and final stop of the bus line are the same
to-report is-circular
  report (item 0 personal_route) = (item (length personal_route - 1) personal_route)
end

;decide which passengers to pick at a stop
to pickup-passengers
  foreach get-passengers-at-stop item current_route_index personal_route [
    if not-full [
      ;pickup passengers from Centraal only if their final destinations are withing the line scope
      ;always pickup passengers from anywhere else
      ifelse current_route_index = 0 or  (current_route_index = (length personal_route - 1) and is-circular)[
        if member? item 1 ? personal_route [
          pick-up-passenger item 0 ?
        ]
      ] [pick-up-passenger item 0 ?]
    ]
  ]
end

;decide which passengers to drop at a stop
to drop-passengers
  
  ifelse current_route_index = 0 or current_route_index = length personal_route - 1[
  ;drop all passengers at the end stops
    foreach bus_passengers [
        drop-off-passenger item 0 ?
    ]
  ][
  ;at any other stop only drop passengers if the stop is their destination
  foreach bus_passengers [
    if item 1 ? = current_stop [
      drop-off-passenger item 0 ?
    ]
  ]
  ]
end

to execute-actions
  ifelse count buses = 1 [
    ;add a fixed number of buses at the beginning
    let i 0
    let buses_count 50
    while [i < (buses_count - 1)] [
      add-bus 3
      set i i + 1
    ]
  ]
  [
    ifelse delayed [
      ;delay departing from Centraal at the beginning
      ;so the busses travel at distance from each other
      if delay = ticks [
        set delayed  False
      ]
    ] [
      if at-stop [
        ;in case the bus is at a stop
        update-current-index ; update the current position index to the current stop
        drop-passengers ; drop passengers according to rules
        pickup-passengers ; pickup passengers according to rules
      ]
      
      ;set the state of the travel as going forward on the path or returning to the first stop
      if current_route_index + 1 = length personal_route [
        set returning True
      ]
      if current_route_index = 0 [
        set returning False
      ]
      
      ;travel towards the next stop in the path
      ifelse returning [
        travel-to item (current_route_index - 1) personal_route
      ] [
      travel-to item (current_route_index + 1) personal_route
      ]
    ]
  ]
end