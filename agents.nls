buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  distance_matrix
  mother_station
  going_in_service
  bus_count
]
 
globals [graph]

;loads the distances matrix in memory
to-report load-distances
  file-open "distances.txt"
  let distances_matrix file-read
  file-close
  report distances_matrix
end

to init-buses
  
  if graph = 0    [
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ]
    
; Initialize your agents here.
  if distance_matrix = 0 [
    set distance_matrix load-distances
    set mother_station 23; to the one of the bus that asked for support (check inbox)
    set going_in_service True
    
  ]
end
  
;station connected to origin that is closer to the destination
to-report station-closer-to-destination [origin destination]
  let minimum_distance measure-distance origin destination
  let nearest_station origin
  
  let adjacent_stations item origin graph
  foreach adjacent_stations [
    let new_distance measure-distance ? destination
    if new_distance < minimum_distance [
      set minimum_distance new_distance
      set nearest_station ?
    ]
  ]
  report nearest_station
end
  


to-report is-connected [origin destination]
  ifelse member? destination item origin graph [
    report True
  ][ report False]
end

to travel-to-destination [origin destination]
  if origin != destination [
    ifelse is-connected origin destination [
      travel-to destination
    ][
      travel-to station-closer-to-destination origin destination
    ]
  ]
end

to-report at-stop 
  report current_stop != -1
end

to go-to-mother_station
  ifelse current_stop = mother_station [
    set going_in_service False
  ][
  ifelse not at-stop [
    travel-to next_stop
  ][
  if not (current_stop = mother_station) [
    travel-to-destination current_stop mother_station 
  ]
  ]
  ]
end

to-report not-full 
  report (bus_type = 1 and length bus_passengers != 12) or (bus_type = 2 and length bus_passengers != 60) or (bus_type = 3 and length bus_passengers != 150)
end
 
to drop-passengers ;drop all the passengers
  foreach bus_passengers [
    drop-off-passenger item 0 ?
  ]
end

to-report measure-distance [station0 station1]
  report item station0 item station1 distance_matrix
end

to-report distance-shortened [station passenger]
  let distance0 measure-distance current_stop item 1 passenger
  let distance1 measure-distance station item 1 passenger
  report distance1 < distance0
end

to-report get-optimal-station
  let best_station (- 1)
  let best_gain 0
  foreach item mother_station graph[ ;for each connected station
    let g 0
    let station ?
    foreach get-passengers-at-stop current_stop[ ; count how many passengers get their trip shortened (distance-shortened)
      if distance-shortened station ? [
        set g (g + 1)
      ]
    ]
    
    ;to consider also how many people are on that station change k to a positive value
    let k 0
    set  g  g + k * length get-passengers-at-stop station
    
    if  g > best_gain[
      set best_gain  g
      set best_station station
    ]
  ]
  report best_station
end

to pickup-passengers [station] ;pick up the passengers that will get a gain from going to that bus stop
  foreach get-passengers-at-stop current_stop [
    if not-full [ ; if the bus has spare places
      if distance-shortened station ? [
        pick-up-passenger item 0 ?
      ]
    ]
  ]
end

to execute-actions
  set bus_count count buses
  
  ifelse going_in_service[
    go-to-mother_station
  ]
  [
    if at-stop [
      drop-passengers
      
      ifelse current_stop = mother_station [
        let best_station get-optimal-station
        pickup-passengers best_station
        travel-to best_station
      ]
      [
        pickup-passengers mother_station
        travel-to mother_station
      ]
    ]
    
    bus-needed? ; function that decides if a bus is needed and in which station
  ]
end



to bus-needed?
  ; consider the number of passengers waiting in your mother_station
  ; consider the number of expected passengers in your mother_station for the next tick
  ; might count the soon to be dropped (communication yeeey)
  ; count the number of buses already on that station
  let m_s mother_station
  let bus_here count buses with [mother_station = m_s] ;this also has to be done with communication (yey2)
  ; if the count seems insufficent -> add-bus 
;  if bus_count < buses-needed[
;    ; add-bus
;    ; send message to the new bus telling it the station to set as main
;  ]
end