buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  distance_matrix
  mother_station
  going_in_service
  
  independent
  ;companions
  
  leader
  fixed_buses
  independent_buses
  new_buses
  
  last_order_tick
  pending_orders
  asked_support
  help_candidates
  wait_help_delay
  help_distance_threshold
]

;hi!
 
globals [graph]

;loads the distances matrix in memory
to-report load-distances
  file-open "distances.txt"
  let distances_matrix file-read
  file-close
  report distances_matrix
end

to init-buses
  if graph = 0    [
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ]
  
  ; Initialize your agents here.
  set fixed_buses []
  set independent_buses []
  set distance_matrix load-distances
  ifelse bus_id <= 49[
    set mother_station (bus_id - 25) mod 24; to the one of the bus that asked for support (check inbox)
    set independent false
    
    let i 25
    while [i < 49] [
      set fixed_buses lput i fixed_buses
      set i (i + 1)
    ]
    set help_candidates []
  ]
  [
    set mother_station -1
  ]
  
  set leader 25
  set last_order_tick 0
  set going_in_service True
  if leader = bus_id[
    set new_buses []
    set pending_orders []
  ]
  set asked_support [false 0]
  set wait_help_delay 0
  set help_distance_threshold 10
  ;set companions lput bus_id []
end
  
;station connected to origin that is closer to the destination
to-report station-closer-to-destination [origin destination]
  let minimum_distance measure-distance origin destination
  let nearest_station origin
  
  let adjacent_stations item origin graph
  foreach adjacent_stations [
    let new_distance measure-distance ? destination
    if new_distance < minimum_distance [
      set minimum_distance new_distance
      set nearest_station ?
    ]
  ]
  report nearest_station
end
  


to-report is-connected [origin destination]
  ifelse member? destination item origin graph [
    report True
  ][ report False]
end

to travel-to-destination [origin destination]
  if origin != destination [
    ifelse is-connected origin destination [
      set next_stop destination
    ]
    [
      set next_stop station-closer-to-destination origin destination
    ]
  ]
end

to-report at-stop 
  report current_stop != -1
end

to go-to-mother_station
  ifelse current_stop = mother_station [
    set going_in_service False
    set next_stop -1
  ]
  [
    if at-stop [
      travel-to-destination current_stop mother_station
    ]
  ]
end

to-report get-capacity
  if bus_type = 1[report 12]
  if bus_type = 2[report 60]
  if bus_type = 3[report 150]
end

to-report full 
  report (length bus_passengers = get-capacity)
end
 
to drop-passengers ;drop all the passengers
  foreach bus_passengers [
    drop-off-passenger item 0 ?
  ]
end

to-report measure-distance [station0 station1]
  report item station0 item station1 distance_matrix
end

to-report distance-shortened [station passenger]
  let distance0 measure-distance current_stop item 1 passenger
  let distance1 measure-distance station item 1 passenger
  report distance1 < distance0
end

to-report get-optimal-station
  let best_station (- 1)
  let best_gain 0
  foreach item mother_station graph[ ;for each connected station
    let g 0
    let station ?
    foreach get-passengers-at-stop current_stop[ ; count how many passengers get their trip shortened (distance-shortened)
      if distance-shortened station ? [
        set g (g + 1)
      ]
    ]
    
    
    let k 0
    ;to consider also how many people are on that station change k to a positive value
    if independent
    [set k 0.5]
    
    set  g  g + k * length get-passengers-at-stop station
    
    if  g > best_gain[
      set best_gain  g
      set best_station station
    ]
  ]
  report best_station
end

to pickup-passengers [station] ;pick up the passengers that will get a gain from going to that bus stop
  let left_down 0
  foreach get-passengers-at-stop current_stop [
    if distance-shortened station ? [ ;if the passenger gains something from the planned trip
      ifelse not full [ 
        pick-up-passenger item 0 ? ;if the bus has spare places it will load the passenger
      ]
      [
        set left_down (left_down + 1) ;the bus counts how many passengers couldn't load
      ]
    ]
  ]
  
  if not independent and left_down > 0[
    ;help-needed left_down
    bus-needed? lput left_down []
  ]
end

to help-needed [left_down]
  ;send-message (item 0 companions) lput left_down ["insufficient-capacity"]
end

to execute-actions
  
  handle-messages
  if mother_station != -1
  [
  
    if ticks = 2 [
      let i 0
      ;let big_stations [0 3 13 16 22 23]
      while [i < 24 ] [
        ;ifelse member? i big_stations[
          add-bus 3
        ;][
        ;  add-bus 2
        ;]
        set i i + 1
      ]
      die
    ]
    
    if at-stop [
      drop-passengers ;everytime you reach a stop you drop all passengers
      ifelse going_in_service[ ; this part decides which will be the next_stop
        go-to-mother_station
      ]
      [
        if independent [ ;independent buses decide their mother_station based on where they are more needed (
          if current_stop != mother_station[
            if (length get-passengers-at-stop mother_station) < (length get-passengers-at-stop current_stop)[
              set mother_station current_stop ; the mother station changes to the current one if this has more passengers than the previous
            ]
          ]
        ]
        
        ifelse current_stop = mother_station [
          set next_stop get-optimal-station
        ]
        [
          set next_stop mother_station
        ]
      ]
      if next_stop != -1[ pickup-passengers next_stop ] ;if no one is waiting in the motherstation the bus don't pickup the air
    ]
    
    if next_stop != -1[ ;if no one is waiting in the motherstation the bus doesn't move.
      travel-to next_stop
    ]

  ]
end

to handle-messages
  let ind 0
  let handled []
  let bus_counter length fixed_buses + length independent_buses
  let help_requests []
  let taken false
  let taken_buses []
  
  while[ind < length inbox ]
  [
    ;if not member? item ind inbox inbox_read [ ;TO BE ADDED so we ignore messagfes that were already read. (ludacris)
    let message item 2 item ind inbox
    let sender item 1 item ind inbox
    let msg_tick item 0 item ind inbox
    let msg_type item 0 message
    
    
    if msg_type = "init"
    [
      set mother_station item 1 message
      
      
;      show mother_station
      
      set independent true
      ; set companions item 2 message
      set fixed_buses item 2 message
      set handled lput (item ind inbox) handled
    ]
    
    if msg_type = "redirect"[
      set mother_station item 1 message
      set going_in_service true
      set handled lput (item ind inbox) handled
      let dist_to_closest 0
      
      
      let station current_stop
      if current_stop = -1
      [
        ifelse previous_stop = -1
        [set dist_to_closest  measure-distance 3 next_stop]
        [set dist_to_closest  measure-distance 3 next_stop]
        set station next_stop]
      let dist dist_to_closest + measure-distance station mother_station
      
      send-message item mother_station fixed_buses lput dist ["confirm-redirect"]
    ]
    
    if msg_type = "ask-help"
    [
      let destination item 1 message
      let preferences item 2 message
      
      let i 0
      while[i < length preferences and member? (item i preferences) taken_buses]
      [
        set i i + 1
      ]
      
      ifelse i < length preferences
      [
        send-message  (item i preferences) lput destination ["redirect"]
        set taken_buses lput (item i preferences) taken_buses
      ]
      [
        send-message leader lput 2 lput destination ["order"]
      ]
      set handled lput (item ind inbox) handled
    ]
    
;    if msg_type = "ask-redirect"
;    [
;      if not taken
;      [
;        send-message sender ["confirm-redirect"]
;        set taken true
;      ]
;      set handled lput (item ind inbox) handled
;    ]
    
    
    if msg_type = "confirm-redirect"
    [
      set wait_help_delay item 1 message
;      set help_candidates lput sender help_candidates
      set handled lput (item ind inbox) handled
    ]
    
;    if msg_type = "new-companion"
;    [
;      set companions lput (item 1 message) companions
;      
;      if bus_id = item 0 companions[
;        foreach companions
;        [
;          if bus_id != ?
;          [send-message ? lput (item 1 message) ["new-companion"]]
;        ]
;      ]
;      set handled lput (item ind inbox) handled
;    ]

    if msg_type = "new-independent"[
      set independent_buses lput (item 1 message) independent_buses
      set handled lput (item ind inbox) handled
    ]
    
    if msg_type = "order"[
      ifelse not member? (item ind inbox) pending_orders
      [
        add-bus (item 2 message)
        let new_bus_id (bus_counter + 25)
        show new_bus_id
        set new_buses lput new_bus_id new_buses
        set pending_orders lput (item ind inbox) pending_orders
        set bus_counter (bus_counter + 1)
      ]
      [
        let sender_mother_station item 1 message
        send-message (item 0 new_buses ) lput fixed_buses lput sender_mother_station ["init"]
        ;send-message sender lput (item 0 new_buses ) ["new-companion"]
        
        set independent_buses lput (item 0 new_buses) independent_buses
        foreach fixed_buses[
          if not (? = bus_id)
          [send-message ? lput (item 0 new_buses ) ["new-independent"] ]; let everyone know there's a new independent bus and its ID
        ]
        
        set pending_orders remove-item 0 pending_orders
        set new_buses remove item 0 new_buses new_buses
        set handled lput (item ind inbox) handled
      ]
    ]
    
     
    if msg_type = "ask-support"[
      if not going_in_service[
        let to_sender_station item 1 message
        let from current_stop
        if current_stop = -1[
          set from next_stop
        ]
        
        let dist measure-distance from to_sender_station
        
        let free_seats (get-capacity - length bus_passengers)
        
        if dist <= help_distance_threshold
        [
          send-message sender lput free_seats lput dist ["info-support"]
        ]
      ]
      set handled lput (item ind inbox) handled
    ]
    
    if msg_type = "info-support"[
      let dist item 1 message
      let free_seats item 2 message
      set help_candidates lput (lput free_seats lput dist lput sender []) help_candidates
      set handled lput (item ind inbox) handled
    ]
    
;    if msg_type = "insufficient-capacity"[
;      ifelse (ticks - msg_tick) < 10[
;        set help_requests lput (item 1 message) help_requests
;      ]
;      [
;        set handled lput (item ind inbox) handled
;      ]
;    ]
    

    
;    foreach message
;    [
;      let submessage ?
;      let msg_type item 0 submessage
;      if msg_type = "init"
;      [
;        set mother_station item 1 submessage
;        set handled lput ind handled
;        ]
;      ]

    set ind (ind + 1)
  ]
  
  if length inbox > 0 [ show inbox ]
      
  foreach handled[ set inbox remove ? inbox ] ;set inbox_read lput ? inbox_read TO BE ADDED so we do not delete messages
  
  if length help_requests > 0[ ;if there were help requests run the procedure to see if a new bus is needed
    bus-needed? help_requests
  ]
  
  if item 0 asked_support [
    if item 1 asked_support + 2 < ticks [
      let preferences get-redirect-preferences
      ifelse preferences = []
        [
          send-message leader lput 2 lput mother_station ["order"]
        ]
        [
          send-message leader lput preferences lput mother_station ["ask-help"]
        ] 
       set asked_support [false 0]
    ]
  ]
  
  
end

to bus-needed? [help_requests]
  let left_down 0
  foreach help_requests[ set left_down (left_down + ?) ] ;how many couldn't be transported even though the bus wanted
  let pas_wait (length get-passengers-at-stop mother_station) ;how many people are right now in the station
  let comp_num 1 ; for now there is only one fixed bus for each stop
  ;let comp_num (length companions) ;how many buses assigned to this stop
  let full_buses (length help_requests) ;how many failed to load all passengers in need
  
  ;let kapacity 100
  
;  ifelse (left_down + pas_wait) > (comp_num - full_buses + 1) * 200[ ;with the addition of one big bus, will we still have passengers waiting?
;    send-message leader lput 3 lput mother_station ["order"] ;send a message to order a new medium bus
;    clean-inbox-order ;when buying a new bus we clean all messages of insufficient-capacity
;  ]
;  [
;    if (left_down + pas_wait) > (comp_num - full_buses + 1) * 125[ ;with the addition of one mediumg bus, will we still have passengers waiting?
;      send-message leader lput 2 lput mother_station ["order"] ;send a message to order a new big bus
;      clean-inbox-order
;    ]
;  ]

  if (left_down + pas_wait) > 150 and (item 1 asked_support ) + ceiling wait_help_delay < ticks[
    ifelse length independent_buses = 0 [
      send-message leader lput 2 lput mother_station ["order"]
    ]
    [
      if not item 0 asked_support
      [
        set help_candidates []
        foreach independent_buses[
          send-message ? lput mother_station ["ask-support"]
        ]
      ]
      
      set asked_support lput ticks [true] ;saves that it has called for support and when ;in handle messages if this is set to true it checks the time, if in two ticks it didn't receive answer it orders a new bus and set it to false
      
    ]
  ]

end
  
to clean-inbox-order
  let ind 0
  let handled []
  
  while[ind < length inbox ] [
    let msg_type item 0 item 2 item ind inbox
    if msg_type = "insufficient-capacity"[ set handled lput (item ind inbox) handled ]
    set ind (ind + 1)
  ]
end
  
;returns list of independent buses in the order of preference or empty list if none are preferred (a new bus is to be created)
to-report get-redirect-preferences
  ;set a trashold distance, to not call buses to far away
  let d_treshold 5
  set help_candidates sort-by [ item 1 ?1 < item 1 ?2 ] help_candidates
  
  let close_buses []
  while [length close_buses < 3 and d_treshold <= help_distance_threshold] [
    set close_buses []
    foreach help_candidates [ if (item 1 ?) < d_treshold [ set close_buses lput ? close_buses ] ]
    set d_treshold (d_treshold + 5)
  ]
  report map [ item 0 ? ] sort-by [ item 2 ?1 > item 2 ?2 ] close_buses
end




















