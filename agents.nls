__includes["support_files/messages.nls" "support_files/distances_calculations.nls" "support_files/passengers_calculations.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  distance_matrix
  passengers_matrix
  mother_station
  going_in_service
  
  station_beliefs
  bus_count
  
  leader
  new_buses
  
  next_destination
  
  eta_next_station
  
  vote_distance_threshold
  faction
  positive_votes
  negative_votes
  initiated_voting_station
  
  last_order_tick
  pending_orders
  
  asked_support
  help_distance_threshold
  
  wait_at_next_station_delay
  
  starting_buses
  
  ;attractiveness protocols
  attractiveness
  
]

globals [graph]

;initialization of the buses
to init-buses
  if graph = 0 [
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ]
  
  ; Initialize your agents here.
  
  set distance_matrix load-distances
  set passengers_matrix load-passengers
  
  set starting_buses 15
  set positive_votes 0
  set negative_votes 0
  set initiated_voting_station -1
  
  set next_destination next_stop
  
  set station_beliefs n-values 24 [ [] ]
  
  let assigned_stations  [15 14 7 23 21 19 12 9 1 20 16 13 11 10 8 3 2 22 18 17 5 0 6 4] ;[8 16 3 10 23 0 5 1 2 4 6 7 9 11 12 13 14 15 17 18 19 20 21 22]
  
  if bus_id = 24
  [
    set bus_count starting_buses + 1
    ]
  
  ifelse bus_id != 24 and bus_id < 24 + starting_buses + 1[
    set mother_station item (bus_id - 25) assigned_stations; mod 24; to the one of the bus that asked for support (check inbox)
    set bus_count starting_buses + 1
    
  ]
  [
    set mother_station -1
  ]
  
  set leader 24
  
  set last_order_tick 0
  set going_in_service True
  
  if leader = bus_id[
    set new_buses []
    set pending_orders []
  ]
  
  set vote_distance_threshold 10
  
  ifelse random 3 = 0[ ;buses can be cheap or fast, randomly assigned with different probabilities (1/3 and 2/3)
    set faction "cheap"
    ;less prone to buy or vote in favour of new buses, they care more about economic efficiency
  ]
  [
    set faction "fast"
    ;more interested in bringing people around faster, they are more likely to order and vote for new buses
  ]
  
  set asked_support []
  set help_distance_threshold 10
  
  
  ;set attractivness []
end


;----utility function

to-report max-index [array]
  report position (max array) array
end


;--------------------------------------------------------;
;--------------------MAIN ROUTINE------------------------;
;--------------------------------------------------------;
to execute-actions
  if bus_id = 24 and ticks = 2 [
    ;let node_stations [0 3 13 16 22 23 ...] ; this are the main nodes of the graph, the ones that have a fixed bus
    foreach n-values starting_buses [?] [ ; [i < length node_stations] [
      add-bus 3
    ]
    set mother_station 3
    stop
  ]
  
  handle-messages
  handle-voting
  
  update-beliefs
  
  if mother_station != -1[
    ifelse at-stop [
      drop-passengers ;everytime you reach a stop you drop all passengers
      if ticks >= wait_at_next_station_delay
      [
        ifelse going_in_service[ ; this part decides which will be the next_stop
          go-to-mother_station
        ]
        [
          ;buses decide their mother_station based on where they are more needed (
          ;        if current_stop != mother_station[
          ;          ;TODO this protocolo has to be improved and also consider other buses destinations and the prior
          ;          if (length get-passengers-at-stop mother_station) < (length get-passengers-at-stop current_stop)[
          ;            set mother_station current_stop ; the mother station changes to the current one if this has more passengers than the previous
          ;          ]
          ;        ]
          ;        
          ;        
          ;        ifelse current_stop = mother_station [
          set next_destination next-best-station 2 ;using recursive attractivness, the number is how far it has to go with measuring recursive attractivness
                                                   ;set next_stop get-optimal-station ;using gain
                                                   ;        ]
                                                   ;        [
                                                   ;          set next_stop mother_station
                                                   ;        ]
        ]
        if next_destination = -1[ ;if no local choice gives gain, search further away
          if consider-migration[
            go-to-mother_station
          ]
        ]
        ;otherwise pickup the passengers that gain from the trip
        
        pickup-passengers next_destination
        update-others-on-choice next_destination
      ]
    ]
    [
      if eta_next_station - ticks < 5 [ waiting-request? ]
    ]
    
    if next_destination != -1[ ;if no one is waiting in the motherstation the bus doesn't move.
      travel-to next_destination
    ]
    
  ]
end

;makes the bus move from origin to destination following the shortest path
to travel-to-destination [origin destination]
  if origin != destination [
    ifelse is-connected origin destination [
      set next_destination destination
    ]
    [
      set next_destination station-closer-to-destination origin destination
    ]
  ]
end

;checks if a bus is stopped at a station or if it's moving
to-report at-stop 
  report current_stop != -1
end

;sends a new bus to its mother station
to go-to-mother_station
  ifelse current_stop = mother_station [
    set going_in_service False
    set next_destination get-optimal-station
  ]
  [
    if at-stop [
      travel-to-destination current_stop mother_station
    ]
  ]
end

;returns the capacity of the given bus
to-report get-capacity
  if bus_type = 1[report 12]
  if bus_type = 2[report 60]
  if bus_type = 3[report 150]
end

;checks if the bus is full
to-report full 
  report (length bus_passengers = get-capacity)
end
 
;drops all the passengers
to drop-passengers
  foreach bus_passengers [
    drop-off-passenger item 0 ?
  ]
end

;pick up the passengers that will get a gain from going to that bus stop
to pickup-passengers [station]
  if station != -1[
    let left_down 0
    foreach get-passengers-at-stop current_stop [
      if distance-shortened current_stop station ? [ ;if the passenger gains something from the planned trip
        ifelse not full [ 
          pick-up-passenger item 0 ? ;if the bus has spare places it will load the passenger
        ]
        [
          set left_down (left_down + 1) ;the bus counts how many passengers couldn't load
        ]
      ]
    ]
    
    let voting_in_process false
    foreach asked_support
    [
      if item 0 ? = current_stop
      [
        set voting_in_process true
        ]
      ]
    
    if (bus-needed? left_down current_stop)[; and not voting_in_process [
      call-vote left_down current_stop
    ]
  ]
  
end

;checks if a new bus needs to be bought or not
to-report bus-needed? [left_down station]
  
  let buses_ordered 0
  foreach asked_support
  [
    if station = item 0 ?
    [
      set buses_ordered buses_ordered + 1
    ]
  ]
  
  
  let pas_wait (length get-passengers-at-stop station) ;how many people are right now in the station
  let bus_coming length item station station_beliefs ; for now there is only one fixed bus for each stop
  let passengers_expected get-passengers-next-quarter station
  
  let threshold 0
  
  ifelse faction = "fast"[
    set threshold 150
  ]
  [
    set threshold 300
  ]
  
  let need (left_down + pas_wait + passengers_expected - bus_coming * 100 - buses_ordered * 100)
  
  report (need > threshold) 
end

to update-beliefs
  let new_b []
  foreach station_beliefs [
    let nsb ?
    ;erase from the list of beliefs the buses that already reached their destination
    let arrived []
    foreach ?[
      if item 1 ? < ticks [ set arrived lput ? arrived ]
    ]
    foreach arrived [ set nsb remove ? nsb ]
    ;start rebuilding the beliefs list with the updated knowledge
    set new_b lput nsb new_b
  ]
  set station_beliefs new_b ;beliefs updated
end

;attractivness estimation of a station by itself
to-report measure-attractivness [ station ]
  let waiting_passengers length get-passengers-at-stop station
  let bus_count_for_stop length item station station_beliefs
  let prior get-passengers-next-quarter station
  
  let att (0.5 * waiting_passengers + 0.5 * prior) - 50 * bus_count_for_stop
  report att
end

;estimate of the acctractivness of a station comprehensive of its connections, recursively weigthed by distance
to-report get-attractivness [ station depth ]
  let a measure-attractivness station
  if depth > 0 [
    foreach item station graph [
      set a (a + (get-attractivness ? (depth - 1)) / ln measure-distance station ?)
    ]
  ]
  if station = mother_station [ set a (1.5 * a) ]
  report a
end

;based on recursive attractivness and passenger gain, it tries to estimates the best stop to go next
to-report next-best-station [depth]
  let connected_stations item current_stop graph
  let gain map [ (2 * passenger-gain current_stop ? + get-attractivness ? depth) ] connected_stations ;/ ln measure-distance current_stop ? ] connected_stations
  ifelse max gain > 0
  [report item max-index gain connected_stations]
  [
    ;if there's no gain prefer not to move
    ;however if there's a bus, move with some proability
    let move_probability 0
    
    if length item current_stop station_beliefs > 0
      [
        set move_probability random-float 1
      ]
    
    ifelse move_probability <= 0.7
    [report (- 1)]
    [
      let random_neighbour_ind random length item current_stop graph
      report item random_neighbour_ind item current_stop graph
    ]
  ]
end

to waiting-request?
  let coincidence find-next-coincidence next_stop
  if length coincidence > 0[
    let wait_time eta_next_station - item 1 coincidence
    if length bus_passengers > 0[
      if waiting-reasonable? wait_time bus_passengers [ ask-to-wait item 0 coincidence wait_time bus_passengers ]
    ]
  ]
end

to-report find-next-coincidence [station]
  let bus_coming filter [item 1 ? < eta_next_station] item station station_beliefs ;other buses coming to my next station before me
  set bus_coming sort-by [item 1 ?1 > item 1 ?2] bus_coming ;order by descending time of arrival
  ifelse length bus_coming > 0 [ report first bus_coming ] [ report [] ] ;report the id of the bus that arrives right before me, if there's none, return zero
end

to-report waiting-reasonable? [ wait_time pass_gain ]
  let connected_stations item next_stop graph
  let avg_travel_time (sum map [measure-distance next_stop ?] connected_stations / length connected_stations);the average lenght of the edges from the next stop
  ;how much time will the new passengers have to wait on average before a new bus comes to the station (very approximated)
  let gain 2 * avg_travel_time * min (list length pass_gain get-capacity) ;this max is because for a bus being full is the maximum gain, it cannot carry more

  let loss wait_time * passenger-forecast
  
  report gain > loss
end

to-report passenger-forecast
  let station0 next_stop
  if station0 = -1 [ set station0 current_stop ]
  report max map [ passenger-gain station0 ? ] item station0 graph
end










