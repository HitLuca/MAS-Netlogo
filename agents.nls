buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  distance_matrix
  mother_station
  going_in_service
  companions
  
  the_chosen_one
  last_order_tick
  new_buses
  pending_orders
]
 
globals [graph]

;loads the distances matrix in memory
to-report load-distances
  file-open "distances.txt"
  let distances_matrix file-read
  file-close
  report distances_matrix
end

to init-buses
  if graph = 0    [
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ]
    
  ; Initialize your agents here.
    if distance_matrix = 0 [
      set distance_matrix load-distances
      ifelse bus_id <= 49[
      set mother_station (bus_id - 25) mod 24; to the one of the bus that asked for support (check inbox)
      ]
      [set mother_station -1]
      set the_chosen_one 25
      set last_order_tick 0
      set going_in_service True
      if the_chosen_one = bus_id
      [set new_buses []
        set pending_orders []
        ]
    ]
  
  set companions lput bus_id []
end
  
;station connected to origin that is closer to the destination
to-report station-closer-to-destination [origin destination]
  let minimum_distance measure-distance origin destination
  let nearest_station origin
  
  let adjacent_stations item origin graph
  foreach adjacent_stations [
    let new_distance measure-distance ? destination
    if new_distance < minimum_distance [
      set minimum_distance new_distance
      set nearest_station ?
    ]
  ]
  report nearest_station
end
  


to-report is-connected [origin destination]
  ifelse member? destination item origin graph [
    report True
  ][ report False]
end

to travel-to-destination [origin destination]
  if origin != destination [
    ifelse is-connected origin destination [
      travel-to destination
    ][
      travel-to station-closer-to-destination origin destination
    ]
  ]
end

to-report at-stop 
  report current_stop != -1
end

to go-to-mother_station
  ifelse current_stop = mother_station [
    set going_in_service False
  ][
  ifelse not at-stop [
    travel-to next_stop
  ][
  if not (current_stop = mother_station) [
    travel-to-destination current_stop mother_station 
  ]
  ]
  ]
end

to-report not-full 
  report (bus_type = 1 and length bus_passengers != 12) or (bus_type = 2 and length bus_passengers != 60) or (bus_type = 3 and length bus_passengers != 150)
end
 
to drop-passengers ;drop all the passengers
  foreach bus_passengers [
    drop-off-passenger item 0 ?
  ]
end

to-report measure-distance [station0 station1]
  report item station0 item station1 distance_matrix
end

to-report distance-shortened [station passenger]
  let distance0 measure-distance current_stop item 1 passenger
  let distance1 measure-distance station item 1 passenger
  report distance1 < distance0
end

to-report get-optimal-station
  let best_station (- 1)
  let best_gain 0
  foreach item mother_station graph[ ;for each connected station
    let g 0
    let station ?
    foreach get-passengers-at-stop current_stop[ ; count how many passengers get their trip shortened (distance-shortened)
      if distance-shortened station ? [
        set g (g + 1)
      ]
    ]
    
    ;to consider also how many people are on that station change k to a positive value
    let k 0
    set  g  g + k * length get-passengers-at-stop station
    
    if  g > best_gain[
      set best_gain  g
      set best_station station
    ]
  ]
  report best_station
end

to pickup-passengers [station] ;pick up the passengers that will get a gain from going to that bus stop
  foreach get-passengers-at-stop current_stop [
    if not-full [ ; if the bus has spare places
      if distance-shortened station ? [
        pick-up-passenger item 0 ?
      ]
    ]
  ]
end

to execute-actions
  
  handle-messages
  if mother_station != -1
  [
  
    if ticks = 2 [
      let i 0
      while [i <= 24 ] [
        add-bus 2
        set i i + 1
      ]
      die
    ]
    
    ifelse going_in_service[
      go-to-mother_station
    ]
    [
      if at-stop [
        drop-passengers
        
        ifelse current_stop = mother_station [
          let best_station get-optimal-station
          pickup-passengers best_station
          set next_stop best_station
        ]
        [
          pickup-passengers mother_station
          set next_stop mother_station
        ]
      ]
      if next_stop != -1[ ;if no one is waiting in the motherstation the bus doesn't move.
        travel-to next_stop
      ]
      
      bus-needed? ; function that decides if a bus is needed and in which station
    ]
  ]
end


to bus-needed?
  ; consider the number of passengers waiting in your mother_station
  ; consider the number of expected passengers in your mother_station for the next tick
  ; might count the soon to be dropped (communication yeeey)
  ; count the number of buses already on that station
  

  
  let threshold 150
  
  if last_order_tick < ticks - 5 and bus_id = (item 0 companions) and (length get-passengers-at-stop mother_station)/(length companions) > threshold
  [ 
    send-message the_chosen_one lput mother_station ["order"]
    set last_order_tick ticks
    ]
  let m_s mother_station
  let bus_here count buses with [mother_station = m_s] ;this also has to be done with communication (yey2)
  ; if the count seems insufficent -> add-bus 
;  if bus_count < buses-needed[
;    ; add-bus
;    ; send message to the new bus telling it the station to set as main
;  ]
end

to handle-messages
  let ind 0
  let handled []
  let bus_counter count buses
  
  while[ind < length inbox ]
  [
    let message item 2 item ind inbox
    let sender item 1 item ind inbox
    let msg_tick item 0 item ind inbox
    let msg_type item 0 message
    
    
    if msg_type = "init"
    [
      set mother_station item 1 message
      set companions item 2 message
      ]
    
    if msg_type = "new-companion"
    [
      set companions lput (item 1 message) companions
      
;      if bus_id = item 0 companions[
;        foreach companions
;        [
;          if bus_id != ?
;          [send-message ? lput (item 1 message) ["new-companion"]]
;        ]
;      ]
      ]
    
    if msg_type = "order"
    [
      if bus_id = the_chosen_one
      [
        
        ifelse not member? (item ind inbox) pending_orders
        [
          add-bus 3
          let new_bus_id (bus_counter + 25)
          set new_buses lput new_bus_id new_buses
          set pending_orders lput (item ind inbox) pending_orders
          set bus_counter (bus_counter + 1)
        ]
        [
          
          let sender_mother_station item 1 message
          send-message (item 0 new_buses ) lput (lput item 0 companions []) lput sender_mother_station ["init"]
          send-message sender lput (item 0 new_buses ) ["new-companion"]
          
          set pending_orders remove-item 0 pending_orders
          set new_buses remove-item 0 new_buses
          set handled lput (item ind inbox) handled
        ]
       ]
     ]
    
    
    if msg_type != "order"
    [set handled lput (item ind inbox) handled
      ]
    
;    foreach message
;    [
;      let submessage ?
;      let msg_type item 0 submessage
;      if msg_type = "init"
;      [
;        set mother_station item 1 submessage
;        set handled lput ind handled
;        ]
;      ]
    set ind (ind + 1)
    ]
  
  foreach handled
  [
    set inbox remove ? inbox
    ]
end