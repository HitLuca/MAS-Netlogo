__includes["support_files/messages.nls" "support_files/distances_calculations.nls" "support_files/passengers_calculations.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  distance_matrix
  passengers_matrix
  mother_station
  going_in_service
  
  independent
  
  ;companions
  
  leader
  fixed_buses
  independent_buses
  new_buses
  
  last_order_tick
  pending_orders
  asked_support
  help_candidates
  wait_help_delay
  help_distance_threshold
]

globals [graph]

;initialization of the buses
to init-buses
  if graph = 0 [
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ]
  
  ; Initialize your agents here.
  set fixed_buses []
  set independent_buses []
  set distance_matrix load-distances
  set passengers_matrix load-passengers
  ifelse bus_id < 49[
    set mother_station (bus_id - 25) ; mod 24; to the one of the bus that asked for support (check inbox)
    set independent false
    
    let i 25
    let f_b []
    while [i < 49] [
      set f_b lput (i - 25) lput i [] ;a list of pairs, first element is the bus_id, second the mother_station
      set fixed_buses lput f_b fixed_buses
      set i (i + 1)
    ]
    set help_candidates []
  ]
  [
    set mother_station -1
  ]
  
  ;set independent (mother_station = -1)
  
  set leader 25
  set last_order_tick 0
  set going_in_service True
  if leader = bus_id[
    set new_buses []
    set pending_orders []
  ]
  set asked_support [false 0]
  set wait_help_delay 0
  set help_distance_threshold 10
  ;set companions lput bus_id []
end

;--------------------------------------------------------;
;--------------------MAIN ROUTINE------------------------;
;--------------------------------------------------------;
to execute-actions
  if bus_id = 24 and ticks = 2 [
    let i 0
    ;let node_stations [0 3 13 16 22 23 ...] ; this are the main nodes of the graph, the ones that have a fixed bus
    while [i < 24 ] [ ; [i < length node_stations] [
      add-bus 3
      set i i + 1
    ]
    ;die
    set independent true
    set mother_station 3
  ]
  
  handle-messages
  
  if mother_station != -1[  
    if at-stop [
      drop-passengers ;everytime you reach a stop you drop all passengers
      ifelse going_in_service[ ; this part decides which will be the next_stop
        go-to-mother_station
      ]
      [
        if independent [ ;independent buses decide their mother_station based on where they are more needed (
          if current_stop != mother_station[
            if (length get-passengers-at-stop mother_station) < (length get-passengers-at-stop current_stop)[
              set mother_station current_stop ; the mother station changes to the current one if this has more passengers than the previous
            ]
          ]
        ]
        
        ifelse current_stop = mother_station [
          set next_stop get-optimal-station
        ]
        [
          set next_stop mother_station
        ]
      ]
      if next_stop != -1[ pickup-passengers next_stop ] ;if no one is waiting in the motherstation the bus don't pickup the air
    ]
    
    if next_stop != -1[ ;if no one is waiting in the motherstation the bus doesn't move.
      travel-to next_stop
    ]
  ]
end

;makes the bus move from origin to destination following the shortest path
to travel-to-destination [origin destination]
  if origin != destination [
    ifelse is-connected origin destination [
      set next_stop destination
    ]
    [
      set next_stop station-closer-to-destination origin destination
    ]
  ]
end

;checks if a bus is stopped at a station or if it's moving
to-report at-stop 
  report current_stop != -1
end

;sends a new bus to its mother station
to go-to-mother_station
  ifelse current_stop = mother_station [
    set going_in_service False
    set next_stop -1
  ]
  [
    if at-stop [
      travel-to-destination current_stop mother_station
    ]
  ]
end

;returns the capacity of the given bus
to-report get-capacity
  if bus_type = 1[report 12]
  if bus_type = 2[report 60]
  if bus_type = 3[report 150]
end

;checks if the bus is full
to-report full 
  report (length bus_passengers = get-capacity)
end
 
;drops all the passengers
to drop-passengers
  foreach bus_passengers [
    drop-off-passenger item 0 ?
  ]
end

;pick up the passengers that will get a gain from going to that bus stop
to pickup-passengers [station]
  let left_down 0
  foreach get-passengers-at-stop current_stop [
    if distance-shortened station ? [ ;if the passenger gains something from the planned trip
      ifelse not full [ 
        pick-up-passenger item 0 ? ;if the bus has spare places it will load the passenger
      ]
      [
        set left_down (left_down + 1) ;the bus counts how many passengers couldn't load
      ]
    ]
  ]
  
  if not independent and left_down > 0[
    ;help-needed left_down
    bus-needed? lput left_down []
  ]
end

;sends a help message to the companion buses
to help-needed [left_down]
  let companions []
  foreach fixed_buses[ ;creates on the fly the list of companions based on the list of fixed buses and their mother_station
    if item 1 ? = mother_station[
      set companions lput item 0 ? companions
    ]
  ]
  send-message item 0 (sort companions) lput left_down ["insufficient-capacity"]
end

;checks if a new bus needs to be bought or not
to bus-needed? [help_requests]
  let left_down 0
  foreach help_requests[ set left_down (left_down + ?) ] ;how many couldn't be transported even though the bus wanted
  let pas_wait (length get-passengers-at-stop mother_station) ;how many people are right now in the station
  let comp_num 1 ; for now there is only one fixed bus for each stop
  ;let comp_num (length companions) ;how many buses assigned to this stop
  let full_buses (length help_requests) ;how many failed to load all passengers in need
  
  ;let kapacity 100
  
;  ifelse (left_down + pas_wait) > (comp_num - full_buses + 1) * 200[ ;with the addition of one big bus, will we still have passengers waiting?
;    send-message leader lput 3 lput mother_station ["order"] ;send a message to order a new medium bus
;    clean-inbox-order ;when buying a new bus we clean all messages of insufficient-capacity
;  ]
;  [
;    if (left_down + pas_wait) > (comp_num - full_buses + 1) * 125[ ;with the addition of one mediumg bus, will we still have passengers waiting?
;      send-message leader lput 2 lput mother_station ["order"] ;send a message to order a new big bus
;      clean-inbox-order
;    ]
;  ]

  if (left_down + pas_wait) > 150 and (item 1 asked_support ) + ceiling wait_help_delay < ticks[
    ifelse length independent_buses = 0 [
      send-message leader lput 2 lput mother_station ["order"]
    ]
    [
      if not item 0 asked_support[
        set help_candidates []
        foreach independent_buses[
          send-message ? lput mother_station ["ask-support"]
        ]
      ]
      
      set asked_support lput ticks [true] ;saves that it has called for support and when ;in handle messages if this is set to true it checks the time, if in two ticks it didn't receive answer it orders a new bus and set it to false
      
    ]
  ]
end
  
;returns a list of independent buses in the order of preference or empty list if none are preferred (a new bus is to be created)
to-report get-redirect-preferences
  let close_buses []
  let d_treshold 5 ;set a trashold distance, to not call buses to far away
  while [length close_buses < 2 and d_treshold <= help_distance_threshold] [
    set close_buses []
    foreach help_candidates [ if (item 1 ?) < d_treshold [ set close_buses lput ? close_buses ] ] ;select only the buses closer then the distance threshold
    set d_treshold (d_treshold + 2) ;if we don't find enough buses under a certain distance we try with a bigger one
  ]
  set close_buses sort-by [ item 1 ?1 > item 1 ?2 ] close_buses ;for the same capacity the closest is chosen
  report map [ item 0 ? ] sort-by [ item 2 ?1 > item 2 ?2 ] close_buses ; this needs to be refined, it has to consider also distance. Often we have the capacity to 0
end




















