buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  distance_matrix
  mother_station
  going_in_service
  
  independent
  companions
  
  leader
  new_buses
  indipendents_buses
  
  last_order_tick
  pending_orders
]

;hi!
 
globals [graph]

;loads the distances matrix in memory
to-report load-distances
  file-open "distances.txt"
  let distances_matrix file-read
  file-close
  report distances_matrix
end

to init-buses
  if graph = 0    [
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ]
    
  ; Initialize your agents here.
    if distance_matrix = 0 [
      set distance_matrix load-distances
      ifelse bus_id <= 49[
        set mother_station (bus_id - 25) mod 24; to the one of the bus that asked for support (check inbox)
        set independent false
      ]
      [
        set mother_station -1
      ]
      
      set leader 25
      set last_order_tick 0
      set going_in_service True
      if leader = bus_id[
        set new_buses []
        set pending_orders []
      ]
    ]
  
  ;set companions lput bus_id []
end
  
;station connected to origin that is closer to the destination
to-report station-closer-to-destination [origin destination]
  let minimum_distance measure-distance origin destination
  let nearest_station origin
  
  let adjacent_stations item origin graph
  foreach adjacent_stations [
    let new_distance measure-distance ? destination
    if new_distance < minimum_distance [
      set minimum_distance new_distance
      set nearest_station ?
    ]
  ]
  report nearest_station
end
  


to-report is-connected [origin destination]
  ifelse member? destination item origin graph [
    report True
  ][ report False]
end

to travel-to-destination [origin destination]
  if origin != destination [
    ifelse is-connected origin destination [
      set next_stop destination
    ][
      set next_stop station-closer-to-destination origin destination
    ]
  ]
end

to-report at-stop 
  report current_stop != -1
end

to go-to-mother_station
  ifelse current_stop = mother_station [
    set going_in_service False
  ]
  [
    if at-stop [
      travel-to-destination current_stop mother_station
    ]
  ]
end

to-report full 
  report (bus_type = 1 and length bus_passengers = 12) or (bus_type = 2 and length bus_passengers = 60) or (bus_type = 3 and length bus_passengers = 150)
end
 
to drop-passengers ;drop all the passengers
  foreach bus_passengers [
    drop-off-passenger item 0 ?
  ]
end

to-report measure-distance [station0 station1]
  report item station0 item station1 distance_matrix
end

to-report distance-shortened [station passenger]
  let distance0 measure-distance current_stop item 1 passenger
  let distance1 measure-distance station item 1 passenger
  report distance1 < distance0
end

to-report get-optimal-station
  let best_station (- 1)
  let best_gain 0
  foreach item mother_station graph[ ;for each connected station
    let g 0
    let station ?
    foreach get-passengers-at-stop current_stop[ ; count how many passengers get their trip shortened (distance-shortened)
      if distance-shortened station ? [
        set g (g + 1)
      ]
    ]
    
    ;to consider also how many people are on that station change k to a positive value
    let k 0
    set  g  g + k * length get-passengers-at-stop station
    
    if  g > best_gain[
      set best_gain  g
      set best_station station
    ]
  ]
  report best_station
end

to pickup-passengers [station] ;pick up the passengers that will get a gain from going to that bus stop
  let left_down 0
  foreach get-passengers-at-stop current_stop [
    if distance-shortened station ? [ ;if the passenger gains something from the planned trip
      ifelse not full [ 
        pick-up-passenger item 0 ? ;if the bus has spare places it will load the passenger
      ]
      [
        set left_down (left_down + 1) ;the bus counts how many passengers couldn't load
      ]
    ]
  ]
  
  if left_down > 0[
    help-needed left_down
  ]
end

to help-needed [left_down]
  send-message (item 0 companions) lput left_down ["insufficient-capacity"]
end

to execute-actions
  
  handle-messages
  if mother_station != -1
  [
  
    if ticks = 2 [
      let i 0
      ;let big_stations [0 3 13 16 22 23]
      while [i < 24 ] [
        ;ifelse member? i big_stations[
          add-bus 3
        ;][
        ;  add-bus 2
        ;]
        set i i + 1
      ]
      die
    ]
    
    if at-stop [
      drop-passengers ;everytime you reach a stop you drop all passengers
      ifelse going_in_service[ ; this part decides which will be the next_stop
        go-to-mother_station
      ]
      [
        if independent [ ;independent buses decide their mother_station based on where they are more needed (
          if current_stop != mother_station[
            if (length get-passengers-at-stop mother_station) < (length get-passengers-at-stop current_stop)[
              set mother_station current_stop ; the mother station changes to the current one if this has more passengers than the previous
            ]
          ]
        ]
        
        ifelse current_stop = mother_station [
          set next_stop get-optimal-station
        ]
        [
          set next_stop mother_station
        ]
      ]
      if next_stop != -1[ pickup-passengers next_stop ] ;if no one is waiting in the motherstation the bus don't pickup the air
    ]
    
    if next_stop != -1[ ;if no one is waiting in the motherstation the bus doesn't move.
      travel-to next_stop
    ]

  ]
end

to handle-messages
  let ind 0
  let handled []
  let bus_counter count buses
  let help_requests []
  
  while[ind < length inbox ]
  [
    ;if not member? item ind inbox inbox_read [ ;TO BE ADDED so we ignore messagfes that were already read. (ludacris)
    let message item 2 item ind inbox
    let sender item 1 item ind inbox
    let msg_tick item 0 item ind inbox
    let msg_type item 0 message
    
    
    if msg_type = "init"
    [
      set mother_station item 1 message
      set independent true
      ; set companions item 2 message
      set handled lput (item ind inbox) handled
    ]
    
    if msg_type = "redirect"
    [
      set mother_station item 1 message
      set going_in_service true
      set handled lput (item ind inbox) handled
    ]
    
    if msg_type = "new-companion"
    [
      set companions lput (item 1 message) companions
      
      if bus_id = item 0 companions[
        foreach companions
        [
          if bus_id != ?
          [send-message ? lput (item 1 message) ["new-companion"]]
        ]
      ]
      set handled lput (item ind inbox) handled
    ]
    
    if msg_type = "order"
    [
      ifelse not member? (item ind inbox) pending_orders
      [
        add-bus (item 2 message)
        let new_bus_id (bus_counter + 25)
        set new_buses lput new_bus_id new_buses
        set pending_orders lput (item ind inbox) pending_orders
        set bus_counter (bus_counter + 1)
      ]
      [
        let sender_mother_station item 1 message
        send-message (item 0 new_buses ) lput companions lput sender_mother_station ["init"]
        send-message sender lput (item 0 new_buses ) ["new-companion"]
        
        set pending_orders remove-item 0 pending_orders
        set new_buses remove-item 0 new_buses
        set handled lput (item ind inbox) handled
      ]
    ]
    
    if msg_type = "insufficient-capacity"[
      ifelse (ticks - msg_tick) < 10[
        set help_requests lput (item 1 message) help_requests
      ]
      [
        set handled lput (item ind inbox) handled
      ]
    ]
    
    show inbox
    
;    foreach message
;    [
;      let submessage ?
;      let msg_type item 0 submessage
;      if msg_type = "init"
;      [
;        set mother_station item 1 submessage
;        set handled lput ind handled
;        ]
;      ]

    set ind (ind + 1)
  ]

  foreach handled[ set inbox remove ? inbox ] ;set inbox_read lput ? inbox_read TO BE ADDED so we do not delete messages
  
  if length help_requests > 0[ ;if there were help requests run the procedure to see if a new bus is needed
    bus-needed? help_requests
  ]
  
end

to bus-needed? [help_requests]
  let left_down 0
  foreach help_requests[ set left_down (left_down + ?) ] ;how many couldn't be transported even though the bus wanted
  let pas_wait (length get-passengers-at-stop mother_station) ;how many people are right now in the station
  let comp_num (length companions) ;how many buses assigned to this stop
  let full_buses (length help_requests) ;how many failed to load all passengers in need
  
  ;let kapacity 100
  
  ;if their combination
  ifelse (left_down + pas_wait) > (comp_num - full_buses) * 200[
    send-message leader lput 3 lput mother_station ["order"] ;send a message to order a new medium bus
    clean-inbox-order ;when buying a new bus we clean all messages of insufficient-capacity
  ]
  [
    if (left_down + pas_wait) > (comp_num - full_buses) * 125[
      send-message leader lput 2 lput mother_station ["order"] ;send a message to order a new big bus
      clean-inbox-order
    ]
  ]
end

to clean-inbox-order
  let ind 0
  let handled []
  
  while[ind < length inbox ] [
    let msg_type item 0 item 2 item ind inbox
    if msg_type = "insufficient-capacity"[ set handled lput (item ind inbox) handled ]
    set ind (ind + 1)
  ]
  
  foreach handled[ set inbox remove ? inbox ]
end